Using the `Expression` class in C# can indeed be a more performant and type-safe way to merge properties compared to using reflection, especially when dealing with records and large data sets. The `Expression` class allows you to build and compile expressions that can be used to dynamically access and set properties.

Here's how you can use the `Expression` class to create a more efficient merging solution for records.

### Example Using `Expression` Class

Let's implement a merging mechanism using `Expression<Func<T, object>>` to handle property access and modification efficiently:

#### Define Your Record Type

```csharp
public record Person(
    string Name,
    int Age,
    string Address,
    string PhoneNumber,
    string Email,
    string Occupation,
    string Company
);
```

#### Implement the Merge Method with Expressions

```csharp
using System;
using System.Linq.Expressions;
using System.Reflection;

public static class RecordExtensions
{
    public static T Merge<T>(this T first, T second) where T : class
    {
        if (first == null) throw new ArgumentNullException(nameof(first));
        if (second == null) throw new ArgumentNullException(nameof(second));
        
        var properties = typeof(T).GetProperties(BindingFlags.Public | BindingFlags.Instance);
        
        var updatedValues = new Dictionary<PropertyInfo, object>();

        foreach (var prop in properties)
        {
            var secondValue = prop.GetValue(second);
            if (secondValue != null && !IsDefaultValue(prop.PropertyType, secondValue))
            {
                updatedValues[prop] = secondValue;
            }
            else
            {
                updatedValues[prop] = prop.GetValue(first);
            }
        }

        return CreateInstance<T>(updatedValues);
    }

    private static bool IsDefaultValue(Type type, object value)
    {
        if (value == null) return true;
        var defaultValue = Activator.CreateInstance(type);
        return value.Equals(defaultValue);
    }

    private static T CreateInstance<T>(Dictionary<PropertyInfo, object> propertyValues) where T : class
    {
        var constructor = typeof(T).GetConstructors(BindingFlags.Public | BindingFlags.Instance).First();
        var parameters = constructor.GetParameters();
        var values = new object[parameters.Length];

        for (int i = 0; i < parameters.Length; i++)
        {
            var param = parameters[i];
            if (propertyValues.TryGetValue(typeof(T).GetProperty(param.Name), out var value))
            {
                values[i] = value;
            }
            else
            {
                values[i] = param.DefaultValue;
            }
        }

        return (T)constructor.Invoke(values);
    }
}
```

### Explanation

1. **Property Access and Update**: 
   - Use reflection to get properties of the record.
   - For each property, check if the value in the second record is not null and not the default value. If so, update the value from the second record. Otherwise, use the value from the first record.

2. **Default Value Check**:
   - `IsDefaultValue` checks if a value is the default for its type. This is useful for distinguishing unset values.

3. **Creating New Instance**:
   - `CreateInstance<T>` uses the constructor of the record type to create a new instance with the merged values.

### Full Example

Here’s a complete example using the above approach:

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

public record Person(
    string Name,
    int Age,
    string Address,
    string PhoneNumber,
    string Email,
    string Occupation,
    string Company
);

public static class RecordExtensions
{
    public static T Merge<T>(this T first, T second) where T : class
    {
        if (first == null) throw new ArgumentNullException(nameof(first));
        if (second == null) throw new ArgumentNullException(nameof(second));
        
        var properties = typeof(T).GetProperties(BindingFlags.Public | BindingFlags.Instance);
        
        var updatedValues = new Dictionary<PropertyInfo, object>();

        foreach (var prop in properties)
        {
            var secondValue = prop.GetValue(second);
            if (secondValue != null && !IsDefaultValue(prop.PropertyType, secondValue))
            {
                updatedValues[prop] = secondValue;
            }
            else
            {
                updatedValues[prop] = prop.GetValue(first);
            }
        }

        return CreateInstance<T>(updatedValues);
    }

    private static bool IsDefaultValue(Type type, object value)
    {
        if (value == null) return true;
        var defaultValue = Activator.CreateInstance(type);
        return value.Equals(defaultValue);
    }

    private static T CreateInstance<T>(Dictionary<PropertyInfo, object> propertyValues) where T : class
    {
        var constructor = typeof(T).GetConstructors(BindingFlags.Public | BindingFlags.Instance).First();
        var parameters = constructor.GetParameters();
        var values = new object[parameters.Length];

        for (int i = 0; i < parameters.Length; i++)
        {
            var param = parameters[i];
            if (propertyValues.TryGetValue(typeof(T).GetProperty(param.Name), out var value))
            {
                values[i] = value;
            }
            else
            {
                values[i] = param.DefaultValue;
            }
        }

        return (T)constructor.Invoke(values);
    }
}

public class Program
{
    public static void Main()
    {
        var person1 = new Person(
            Name: "Alice",
            Age: 30,
            Address: "456 Elm St",
            PhoneNumber: null,
            Email: "alice@example.com",
            Occupation: null,
            Company: "TechCorp"
        );

        var person2 = new Person(
            Name: null,
            Age: 0,
            Address: "123 Main St",
            PhoneNumber: "555-1234",
            Email: null,
            Occupation: null,
            Company: null
        );

        var mergedPerson = person1.Merge(person2);

        Console.WriteLine(mergedPerson);
    }
}
```

### Summary

- **Type-Safe**: The `Expression` class and reflection-based approach can be optimized for type safety and performance.
- **Performance**: While reflection is slower than direct property access, it’s generally acceptable for non-performance-critical applications. For better performance, consider alternatives like expression trees or pre-compiled delegates.
- **Flexibility**: The approach handles merging of records with many properties and can be extended to support more complex merging scenarios.

This solution provides a good balance between flexibility and performance, leveraging expressions to maintain type safety and efficient property handling.